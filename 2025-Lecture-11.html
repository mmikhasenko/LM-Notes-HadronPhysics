<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mikhail Mikhasenko">

<title>lecture-11 – Hadron Physics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 21.8em;
  margin: 0 21.8em 21.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-a6e161b2431e1f94a14e0f5d32135a3c.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7d3a565c23c4d3b0e7c030e96a8964f3.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#thresholds-branch-points-and-resonances-in-ππ-scattering" id="toc-thresholds-branch-points-and-resonances-in-ππ-scattering" class="nav-link active" data-scroll-target="#thresholds-branch-points-and-resonances-in-ππ-scattering"><span class="header-section-number">21.1</span> Thresholds, Branch Points, and Resonances in ππ Scattering</a></li>
  <li><a href="#poles-bound-states-and-virtual-states-in-scattering-amplitudes" id="toc-poles-bound-states-and-virtual-states-in-scattering-amplitudes" class="nav-link" data-scroll-target="#poles-bound-states-and-virtual-states-in-scattering-amplitudes"><span class="header-section-number">21.2</span> Poles, Bound States, and Virtual States in Scattering Amplitudes</a></li>
  <li><a href="#breakup-momentum-plane-and-lattice-qcd-in-scattering-theory" id="toc-breakup-momentum-plane-and-lattice-qcd-in-scattering-theory" class="nav-link" data-scroll-target="#breakup-momentum-plane-and-lattice-qcd-in-scattering-theory"><span class="header-section-number">21.3</span> Breakup Momentum Plane and Lattice QCD in Scattering Theory</a></li>
  <li><a href="#lagrangian-path-integral-and-euclidean-time-in-qcd" id="toc-lagrangian-path-integral-and-euclidean-time-in-qcd" class="nav-link" data-scroll-target="#lagrangian-path-integral-and-euclidean-time-in-qcd"><span class="header-section-number">21.4</span> Lagrangian, Path Integral, and Euclidean Time in QCD</a></li>
  <li><a href="#integrating-fermionic-fields-and-quenched-calculations-in-lattice-qcd" id="toc-integrating-fermionic-fields-and-quenched-calculations-in-lattice-qcd" class="nav-link" data-scroll-target="#integrating-fermionic-fields-and-quenched-calculations-in-lattice-qcd"><span class="header-section-number">21.5</span> Integrating Fermionic Fields and Quenched Calculations in Lattice QCD</a></li>
  <li><a href="#fermionic-action-gluon-dependence-and-grassmann-variables-in-qcd" id="toc-fermionic-action-gluon-dependence-and-grassmann-variables-in-qcd" class="nav-link" data-scroll-target="#fermionic-action-gluon-dependence-and-grassmann-variables-in-qcd"><span class="header-section-number">21.6</span> Fermionic Action, Gluon Dependence, and Grassmann Variables in QCD</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mikhail Mikhasenko </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="thresholds-branch-points-and-resonances-in-ππ-scattering" class="level3" data-number="21.1">
<h3 data-number="21.1" class="anchored" data-anchor-id="thresholds-branch-points-and-resonances-in-ππ-scattering"><span class="header-section-number">21.1</span> Thresholds, Branch Points, and Resonances in ππ Scattering</h3>
<p>The threshold for <strong>ππ scattering</strong> is at: <span class="math display">
\sqrt{s} = 2m_\pi
</span> Are there any other open channels? Let’s assume there are no other open channels.</p>
<p>The <strong>branch point</strong> is located at: <span class="math display">
s = (2m_\pi)^2
</span> The branch cut should be drawn from the branch point to the right to satisfy causality.</p>
<p>There is also a <strong>cross channel</strong> to this reaction because ππ scattering isn’t the only possible process. If we consider backward scattering in energy, another π can scatter to another π. For example:</p>
<ul>
<li><strong>π⁺π⁻</strong> can scatter to <strong>π⁺π⁻</strong></li>
<li>Equivalently, <strong>π⁺</strong> can scatter with <strong>π⁺</strong> if we rearrange the particles</li>
</ul>
<p>This means there is another branch point on the left side from the cross channel.</p>
<hr>
<p>When discussing <strong>scattering amplitudes</strong>, we visualize a “blob” connecting the initial and final states. For ππ scattering:</p>
<ol type="1">
<li>We draw the blob with time moving in one direction</li>
<li>Initial pions come together, interact, and then scatter out</li>
<li>This defines a physical process with well-defined kinematics</li>
</ol>
<p>For this process to occur, the total energy must exceed the threshold: <span class="math display">
\sqrt{s} &gt; 2m_\pi
</span> The <strong>Mandelstam variables</strong> s and t describe the kinematics:</p>
<ul>
<li><strong>s</strong> is positive above threshold</li>
<li><strong>t</strong> is negative for elastic scattering (represents momentum transfer)</li>
</ul>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>The scattering amplitude is an analytic function of s and t, defined across the entire complex plane - even for unphysical values. This allows us to study processes like π₁π̄₃ → π₂π₄ through <strong>crossing symmetry</strong> by exchanging s and t.</p>
</div>
</div>
</div>
<hr>
<p>In the <strong>s-plane</strong>:</p>
<ul>
<li><strong>Positive s</strong>: s-channel scattering</li>
<li><strong>Negative s</strong>: t-channel or u-channel contributions</li>
</ul>
<p>The amplitude has singularities, but we can <strong>analytically continue</strong> it to a second Riemann sheet, where resonant states appear. For example:</p>
<ul>
<li>In ππ P-wave scattering, the <strong>ρ meson</strong> appears as a resonance</li>
<li>In the quark model, mesons are organized by energy levels (<strong>1s, 1p, 2s</strong>, etc.) with hyperfine splitting due to spin interactions</li>
<li>The ρ meson and pion differ only in their <strong>spin wavefunctions</strong></li>
</ul>
<p>Unlike in electromagnetism (where transitions occur via photon emission), in QCD:</p>
<ul>
<li>The ρ meson decays to ππ by emitting another pion</li>
<li>This occurs because quark-antiquark pairs can be easily created from the vacuum</li>
</ul>
<hr>
<p>The ρ meson appears as a <strong>resonance</strong> in ππ scattering - when two pions interact, they “feel” the ρ meson, leading to a peak in the cross section. This corresponds to a pole in the complex plane.</p>
<p>To fully understand resonances, we must analytically continue the amplitude to the second sheet. The classification includes:</p>
<ol type="1">
<li><strong>Resonances</strong>: appear as peaks above threshold</li>
<li><strong>Virtual states</strong>: lie on unphysical sheets below threshold</li>
<li><strong>Bound states</strong>: on the physical sheet below threshold</li>
</ol>
<p>The cross section σ is related to the amplitude A by: <span class="math display">
\sigma \propto (2J + 1) |A_J(s)|^2 \rho(s)
</span> where: <span class="math display">
\rho(s) = \frac{2k}{\sqrt{s}}
</span> is the <strong>phase space factor</strong>, and k is the breakup momentum: <span class="math display">
k = \frac{\sqrt{s-4m_\pi^2}}{2}
</span></p>
<hr>
<p>For different states:</p>
<ul>
<li><strong>Resonance</strong>: cross section peaks at the resonance mass</li>
<li><strong>Bound state</strong>: signal appears below threshold</li>
</ul>
<p>The <strong>analytic structure</strong> of the amplitude determines these features. In summary:</p>
<ul>
<li>Singularities in the scattering amplitude correspond to physical states</li>
<li>Their positions reveal whether they are resonances, virtual states, or bound states</li>
</ul>
</section>
<section id="poles-bound-states-and-virtual-states-in-scattering-amplitudes" class="level3" data-number="21.2">
<h3 data-number="21.2" class="anchored" data-anchor-id="poles-bound-states-and-virtual-states-in-scattering-amplitudes"><span class="header-section-number">21.2</span> Poles, Bound States, and Virtual States in Scattering Amplitudes</h3>
<p>For the <strong>bound state</strong> of the virtual state, there should be a peak below threshold. For the <strong>virtual state</strong>, there should just be a threshold cusp.</p>
<p>The peak below the threshold is <strong>divergent</strong>—it goes to infinity at this point. In contrast, the branch point has poles. The amplitude is undefined, or infinity, at the pole. Therefore, the poles are <strong>strong singularities</strong>. They truly make the amplitude infinite.</p>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Key distinction</strong>:</p>
<ul>
<li>Bound state pole: <span class="math inline">E = -E_b</span> (with <span class="math inline">E_b &gt; 0</span>)</li>
<li>Virtual state pole: <span class="math inline">E = -E_v + i0^+</span> (with <span class="math inline">E_v &gt; 0</span>)</li>
</ul>
</div>
</div>
</div>
<p>Imagine taking this pole and moving it closer to the physical axis, where measurements are made. The closer it gets, the higher the cross-section value becomes, and the smaller the width. This distance to the pole is called the <strong>width of the resonance</strong>, <span class="math inline">\Gamma</span>. The smaller the width, the narrower the peak, but also the stronger the resonance effect.</p>
<p><span class="math display">
E = E_0 - i\frac{\Gamma}{2}
</span></p>
<p>where <span class="math inline">E_0</span> is the resonance energy and <span class="math inline">\Gamma</span> is the width.</p>
<hr>
<p>This also explains why <strong>bound states</strong> and <strong>virtual states</strong> produce enhancements. The pole creates an infinity at a specific point, but since measurements start above the threshold, the observed effect is finite. The physical values are still influenced by the pole’s proximity.</p>
<p>For a <strong>bound state</strong>, the amplitude is infinite below the threshold. However, since measurements occur above the threshold, we observe a finite effect. A bound state is a <strong>real particle</strong> that can propagate. Once produced, it does not decay—it lives forever because it has no width.</p>
<p><span class="math display">
\sigma(E) \sim \frac{1}{(E - E_{\text{th}} + E_b)^2 + \Gamma^2/4}
</span></p>
<hr>
<p>Real particles are like poles below the threshold but with a small imaginary part. They are slightly shifted due to other interaction channels. Think of these particles as bound states in the limit where other interactions—like electromagnetic or weak forces—are turned off.</p>
<p>For example, if weak interactions are absent, the <span class="math inline">B</span> meson remains stable because flavor is conserved. In reality, weak interactions cause the <span class="math inline">B</span> meson to decay. This is why the bound state pole in any amplitude is slightly shifted downward.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Flavor conservation in strong interactions</strong>: <span class="math display"> [H_{\text{strong}}, Q_{\text{flavor}}] = 0 </span> where <span class="math inline">Q_{\text{flavor}}</span> is a flavor quantum number.</p>
</div>
</div>
</div>
<hr>
<p>The discussion focuses on <strong>pole positions</strong> in the complex energy plane and their observable effects (peaks, cusps, and enhancements) in scattering amplitudes and cross-sections. The key distinction is between:</p>
<ul>
<li><strong>Bound states</strong> (poles on the real axis below threshold)</li>
<li><strong>Virtual states</strong> (poles on the second Riemann sheet near threshold)</li>
<li><strong>Resonances</strong> (poles near the physical region with finite width).</li>
</ul>
<p>For <strong>virtual states</strong>, the threshold cusp behavior is: <span class="math display">
\sigma(E) \sim \frac{1}{\sqrt{E - E_{\text{th}}}} \quad \text{near } E = E_{\text{th}}
</span></p>
</section>
<section id="breakup-momentum-plane-and-lattice-qcd-in-scattering-theory" class="level3" data-number="21.3">
<h3 data-number="21.3" class="anchored" data-anchor-id="breakup-momentum-plane-and-lattice-qcd-in-scattering-theory"><span class="header-section-number">21.3</span> Breakup Momentum Plane and Lattice QCD in Scattering Theory</h3>
<p>As a main part, another convenient representation of the singularity of the scattering amplitude is the <strong>breakup momentum plane</strong>. The scattering amplitude is only a function of the breakup momentum <span class="math inline">P</span> in non-relativistic scattering. When you consider a non-relativistic problem, you don’t have a <span class="math inline">\sqrt{s}</span> anywhere. You only deal with <span class="math inline">P</span>.</p>
<p>If you look at the expression for <span class="math inline">\rho</span>, where <span class="math inline">\rho = \frac{2P}{\sqrt{s}}</span>, in the non-relativistic limit this simplifies to <span class="math inline">\rho = 2P</span>. You can expand the amplitude near the threshold by expanding it in <span class="math inline">\sqrt{s}</span> near the first branch point. This leads to the expression for <span class="math inline">P</span>:</p>
<p><span class="math display">
P = 2\mu \sqrt{E - E_{\text{threshold}}}
</span></p>
<p>This quantity has a <strong>branch point</strong> at <span class="math inline">s = s_{\text{threshold}}</span> because it’s under a square root, matching the branch point of the amplitude. You can also find the inverse relation and determine how <span class="math inline">s</span> is related to <span class="math inline">P</span>.</p>
<p>The key point is that if the amplitude is only a function of <span class="math inline">P</span>, the square root will never appear. There is no <span class="math inline">\sqrt{P}</span> in the amplitude—it is actually an <strong>analytic function</strong> of <span class="math inline">P</span>.</p>
<p>What we discussed earlier with the first and second sheets now merges into a single complex plane.</p>
<ul>
<li>The <strong>upper part</strong> represents <span class="math inline">A(P)</span>.</li>
<li>The <strong>lower part</strong> represents <span class="math inline">A_2(P)</span>. The real physics corresponds to <span class="math inline">P</span> being real and positive, which maps to <span class="math inline">s</span>.</li>
</ul>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Pole positions in the <span class="math inline">P</span>-plane</strong>:</p>
<ul>
<li><strong>Bound state</strong>: On the positive imaginary axis (<span class="math inline">P = i|P|</span>).</li>
<li><strong>Virtual state</strong>: On the negative imaginary axis (<span class="math inline">P = -i|P|</span>).</li>
<li><strong>Resonances</strong>: Complex-conjugate pairs in the lower-half plane (<span class="math inline">P = \text{Re}(P) - i\text{Im}(P)</span>).</li>
</ul>
</div>
</div>
</div>
<p>Let me quickly sketch where the bound and virtual states are in this representation.</p>
<ul>
<li>The <strong>bound state</strong> sits on the real axis just below the threshold.</li>
<li>The <strong>virtual state</strong> is also on the real axis but above the threshold.</li>
<li><strong>Resonances</strong> appear as pairs in the complex plane.</li>
</ul>
<p>This is the breakup momentum plane, often used in non-relativistic field theory. It simplifies visualization because all objects (bound states, virtual states, resonances) appear in one picture. However, this representation works as an expansion near the threshold and becomes complicated with higher thresholds or additional branch points.</p>
<hr>
<p>To summarize: We’ve discussed <strong>scattering theory</strong>, widely used in hadron spectroscopy. Unlike field theory, this approach doesn’t start from a Lagrangian but uses general principles of scattering theory—<strong>unitarity</strong>, <strong>analyticity</strong>, and <strong>crossing symmetry</strong>.</p>
<ul>
<li><strong>Resonances</strong> are identified as poles of the scattering amplitude.</li>
<li>The amplitude is constructed to satisfy these principles and fitted to experimental data.</li>
<li>Once fixed, it reveals its analytic structure, including branch points and poles on unphysical sheets.</li>
</ul>
<p>In experimental particle physics, we:</p>
<ol type="1">
<li>Constrain this amplitude using data.</li>
<li>Analytically continue it.</li>
<li>Locate poles.</li>
</ol>
<p>The <strong>pole position</strong> gives the mass and width, while the <strong>residue</strong> (from the Cauchy integral) quantifies the coupling strength. These values are tabulated in the <strong>Particle Data Group</strong> for future reference.</p>
<p><strong>Question:</strong> What changes if we add spin to the particles? For example, in <span class="math inline">\rho \rho</span> scattering compared to <span class="math inline">\pi \pi</span> scattering? The short answer is: nothing fundamental changes except kinematics.</p>
<ul>
<li>The amplitude gains extra <strong>kinematic factors</strong> at threshold.</li>
<li>It becomes a <strong>vector of amplitudes</strong> due to different helicity states. For <span class="math inline">\rho \rho</span> scattering, there are multiple amplitudes corresponding to different helicity combinations. However, the <strong>analytic structure</strong> and <strong>pole interpretation</strong> remain the same.</li>
</ul>
<hr>
<p>QCD is a <strong>gauge theory</strong> with an <span class="math inline">SU(3)</span> gauge group, featuring <strong>confinement</strong> and <strong>asymptotic freedom</strong>.</p>
<ul>
<li>At <strong>high momentum</strong>, quarks behave as free particles.</li>
<li>At <strong>low energy</strong>, they confine into hadrons.</li>
</ul>
<p>This makes QCD difficult to study analytically because perturbation theory fails—the coupling is too strong at low energies.</p>
<p>One powerful method is <strong>lattice QCD</strong>, where we:</p>
<ol type="1">
<li>Discretize spacetime into a grid (e.g., a <span class="math inline">2 \text{ fm} \times 2 \text{ fm} \times 2 \text{ fm}</span> box).</li>
<li>Solve the equations numerically.</li>
</ol>
<p>We use <strong>periodic boundary conditions</strong>, meaning the field at one edge matches the field at the opposite edge. This effectively tiles space with identical copies of the box.</p>
<p>Key parameters:</p>
<ul>
<li><strong>Lattice spacing</strong> <span class="math inline">a</span> (e.g., <span class="math inline">21.1 \text{ fm}</span>).</li>
<li><strong>Box size</strong> <span class="math inline">L = N \cdot a</span>.</li>
</ul>
<p>We want the lattice:</p>
<ul>
<li>Large enough to fit hadrons (e.g., a meson of size <span class="math inline">\sim 1 \text{ fm}</span>).</li>
<li>Small enough to avoid interactions with mirrored images.</li>
</ul>
<p>The QCD Lagrangian has few parameters:</p>
<ul>
<li>The coupling <span class="math inline">g</span>.</li>
<li>Quark masses <span class="math inline">m_f</span>.</li>
</ul>
<p>On the lattice, we tune these parameters to match physical observables (e.g., the pion mass <span class="math inline">m_\pi</span>). Interestingly, we can explore “alternative universes” by varying quark masses continuously. For example:</p>
<ul>
<li>A resonance like the <span class="math inline">\rho</span>-meson can become a <strong>bound state</strong> if quark masses are increased.</li>
<li>The pion mass follows <span class="math inline">m_\pi \propto \sqrt{m_q}</span> in the <strong>chiral limit</strong>.</li>
</ul>
<p>Lattice QCD allows us to study these transitions numerically, providing insights into hadron structure and interactions.</p>
<hr>
<ul>
<li><strong>Lighter quarks</strong> (e.g., up/down) make calculations more expensive because the pion mass appears in denominators, increasing uncertainty.</li>
<li>The <strong>lattice spacing</strong> <span class="math inline">a</span> sets the scale—everything is measured in units of <span class="math inline">a</span>.</li>
<li><strong>Finer lattices</strong> (smaller <span class="math inline">a</span>) improve accuracy but raise computational costs.</li>
</ul>
<p><strong>Question:</strong> How is quark mass defined on the lattice? It’s <strong>dimensionless</strong>, expressed as <span class="math inline">m_q a</span>, where <span class="math inline">a</span> is the lattice spacing. The optimal choice balances precision and computational feasibility.</p>
<hr>
<p>This framework—combining <strong>scattering theory</strong> and <strong>lattice QCD</strong>—provides a powerful toolkit for understanding strong interactions. Next, we’ll dive deeper into the technical details of lattice calculations.</p>
</section>
<section id="lagrangian-path-integral-and-euclidean-time-in-qcd" class="level3" data-number="21.4">
<h3 data-number="21.4" class="anchored" data-anchor-id="lagrangian-path-integral-and-euclidean-time-in-qcd"><span class="header-section-number">21.4</span> Lagrangian, Path Integral, and Euclidean Time in QCD</h3>
<p>The <strong>Lagrangian</strong> is a scalar quantity and it’s written as <span class="math inline">G_{\mu \nu} G^{\mu \nu}</span>. This is the gluonic tensor energy momentum. This is a gluonic field tensor contracted with another one. All repeated indices are contracted among the gluonic fields. There are eight of them. And then <span class="math inline">\mu \nu</span> everywhere. Here are Lorentz indices. They are relativistic properties, Lorentz group properties of the fields.</p>
<hr>
<p>There is <strong>gauge invariance</strong> hidden here. That is enforced by extending the derivative with the gluonic field. So fermionic fields here are the quarks; they interact with the gluon. And the way they interact is given by the gauge theory through this term that appears in the combination of the quarks and gluons through these terms.</p>
<p>The mass term is present explicitly. And then here you see these three parameters or these <span class="math inline">N</span> parameters of the field. <span class="math inline">g</span> is one of them, and the quark masses are others. The rest is fixed.</p>
<hr>
<p>So we have fields—we have the gluonic fields and the quark fields. When we say fields, what we really mean is that both <span class="math inline">\psi</span> and <span class="math inline">A_\mu</span> are functions of the point in spacetime. And any physical observable in this can be computed as an expectation value.</p>
<p>This is my notation. This is an operator. Let me write: this is an operator that can depend on it. What kind of operators are we talking about? You put together quarks and gluons, and you can measure the expectation of this operator by sandwiching it with the vacuum, and this is something you can observe.</p>
<hr>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>The expectation value is something you can compute. It’s no longer a function of the coordinates. The operator can depend on the fields like <span class="math inline">\psi</span> and <span class="math inline">A_\mu</span>.</p>
</div>
</div>
</div>
<p>The notion of <strong>local</strong> and <strong>non-local operators</strong> is intuitive.</p>
<ul>
<li><strong>Local</strong>: Evaluated at a single spacetime point.</li>
<li><strong>Non-local</strong>: Evaluated across multiple spacetime points.</li>
</ul>
<hr>
<p>Starting from Feynman’s ideas, the <strong>path integral technique</strong> has been developed, and it suggests a way to compute the expectation value of the operator using the functional integral. Let’s spend two minutes discussing what is actually written here, because this expression you might not have seen before, and conceptually this path integral is a difficult object.</p>
<p>So here, all is also a function of the fields—we just write explicitly <span class="math inline">\psi</span> and <span class="math inline">\bar{\psi}</span>. Do we have a <span class="math inline">T</span>-product yet? Time-ordered? Yes. And time ordering is needed here. If you have several operators, you have to time-order them. Here we have one. So if you want to proceed and expand this, you will get time-ordered. I don’t want to go into these details in this case.</p>
<hr>
<p>Did you cover path integrals? Let’s see if all symbols are clear. Let’s start with that. So <span class="math inline">S</span> is called the <strong>action</strong>, and this is the integral over all coordinates of the Lagrangian. This action weights different configurations.</p>
<p>So this is the complex factor that, for any given configuration of the field—you tell me what <span class="math inline">A_\mu</span> in spacetime is, what <span class="math inline">\psi</span> and <span class="math inline">\bar{\psi}</span> are—I can tell you what this weight factor is by just computing the Lagrangian integrated over spacetime.</p>
<p>You can think of spacetime, and at every point in spacetime, you know what your field is. Then you can compute this integral. You know the factor; you can weigh this configuration.</p>
<hr>
<p>So the input to this weighting factor is a map of spacetime—how <span class="math inline">A_\mu</span> and <span class="math inline">\psi</span> look. You tell me not just a single value; you need to tell me what <span class="math inline">\psi</span> and <span class="math inline">\bar{\psi}</span> are at every point in spacetime. Therefore, the input to this expression is the functional form. So what <span class="math inline">A_\mu</span> is as a function of spacetime, what <span class="math inline">\psi</span> is as a function of spacetime. And what I’m going to integrate over is all possible functional forms. So this is a <strong>functional integral</strong>.</p>
<p><span class="math inline">\psi</span> and <span class="math inline">\bar{\psi}</span> are considered to be independent and are described by <strong>Grassmann variables</strong> (anti-commuting). I have another variable—I’ve been looking at Grassmann variables. It’s so much fun preparing this lecture. Maybe I have time to show you what that means.</p>
<hr>
<p>But if you want to compute any expectation value, this is what you have to do. That’s how your expectation value is defined: integrate over all possible configurations of the fields, your operator that depends on the fields, and weight this with the complex factor.</p>
<p>This is not practical for many reasons, and one of them is that this factor oscillates rapidly. So it’s a complex function. And if you try to do this on a lattice, you can sample different field configurations, but you quickly realize that this doesn’t converge.</p>
<hr>
<p>And then the trick has been invented by changing real time to imaginary time. So we are going to go from Minkowski time and Minkowski metric to Euclidean time, equating the dimension of time with space. And then you will see that what happens is the action becomes a real number, and this <span class="math inline">e^{iS}</span> will become just a real weighting factor—a real number saying that this configuration has a probability of 21.1, this configuration has a probability of 21.5.</p>
<p>So the trick—and this is super important, essential, the main trick on the lattice—is to compute with Euclidean time rather than Minkowski time. We’re going to change the time, introduce a different variable <span class="math inline">t_E</span>, defined as <span class="math inline">t_E = it</span>.</p>
<hr>
<p>Here is an example for the scalar field of how this transformation works. What I’m trying to demonstrate here is that the Lagrangian changes. So from the QCD Lagrangian, you’re going to get this Euclidean version of the QCD Lagrangian, because the time derivatives are going to pick up an <span class="math inline">i</span> due to that, and the time derivative term changes sign.</p>
<p>For the fermion field, you have to do a little more. The gamma matrices also change, and you have to update them. Well, the derivative here changes, the gamma matrices change. But that’s—I think that’s it.</p>
<hr>
<p>But what we are going to write, we find out that the Lagrangian for the action—the action—so what we see here is that for that simple example of the Lagrangian of the scalar field, there is an overall minus sign. So that term becomes a minus sum over four components of the new Euclidean coordinates minus the mass term.</p>
<p>So the whole expression is real and positive, and the action that we see here becomes real because of the integration variable. Here we had the action—the Minkowski action had a <span class="math inline">d^4x</span>, but now time is imaginary. One of the <span class="math inline">i</span>’s pops out and cancels the <span class="math inline">i</span> here, and the whole weighting factor becomes real.</p>
<p>Moreover, since the Lagrangian now is bound to be positive, the weight factor is bound to be less than 1—between 0 and 1. So I think I will.</p>
<hr>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Key formulas discussed:</p>
<ul>
<li>Gluon field strength tensor: <span class="math inline">G_{\mu\nu} G^{\mu\nu}</span></li>
<li>Euclidean path integral weight: <span class="math inline">e^{iS_{\text{Minkowski}}} \rightarrow e^{-S_{\text{Euclidean}}}</span></li>
<li>Wick rotation: <span class="math inline">t_E = it</span>, <span class="math inline">S_{\text{Minkowski}} \rightarrow -S_{\text{Euclidean}}</span></li>
</ul>
</div>
</div>
</div>
</section>
<section id="integrating-fermionic-fields-and-quenched-calculations-in-lattice-qcd" class="level3" data-number="21.5">
<h3 data-number="21.5" class="anchored" data-anchor-id="integrating-fermionic-fields-and-quenched-calculations-in-lattice-qcd"><span class="header-section-number">21.5</span> Integrating Fermionic Fields and Quenched Calculations in Lattice QCD</h3>
<p>So it’s quarter to four, guys. I need ten more minutes. I would really like to show you how we get to the <strong>quenched one-page calculations</strong>, and we’ll continue next time. I will clarify in a second. Let me just put it on the board.</p>
<hr>
<p>The equations—another trick we are going to use is to get rid of the two fermionic fields. In the original equations, we had three types: <span class="math inline">\bar{\psi}</span>, <span class="math inline">\psi</span>, and fermionic. Despite being correlated, they are the same field but conjugated. It’s convenient to consider them independent, taking into account that they have to be anticommuting. For this, we use a trick—a gluonic field.</p>
<p>The gluonic field turns out to be the one that leads to <strong>confinement</strong> and is the trickiest one. It’s not easy to get rid of, and it drives thermodynamics. The gluonic field is truly important and is going to remain. But we want to integrate over the fermionic fields.</p>
<hr>
<p>The way to do this is to look at the original expression and notice that the fermionic fields are weighted with an exponential factor that has a Gaussian form. This integral is a well-known integral for <strong>Grassmann variables</strong>. When <span class="math inline">\psi</span> and <span class="math inline">\bar{\psi}</span> are anticommuting, this integral is easy to evaluate. What you get is the determinant of <span class="math inline">M</span>.</p>
<p>Here, it’s kind of bizarre mathematics because everything here are operators, and you integrate not over <span class="math inline">\psi</span> but over all possible functional forms of it. But it works similarly to real variables.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Grassmann variable anticommutation relation</strong>: <span class="math display">
\{X, Y\} = XY + YX = 0 \quad \Rightarrow \quad XY = -YX
</span> <span class="math display">
X^2 = Y^2 = 0
</span> <strong>Exponential of Grassmann variables</strong>: <span class="math display">
e^{1 - XY} = 1 - XY
</span></p>
</div>
</div>
</div>
<p>I was trying to convince myself by looking at a simple example of Grassmann variables. Grassmann means they anticommute: <span class="math inline">XY = -YX</span>. That means <span class="math inline">X^2 = Y^2 = 0</span>. If you write <span class="math inline">XYXY</span> and swap <span class="math inline">Y</span> and <span class="math inline">X</span>, you get <span class="math inline">X^2Y^2 = 0</span>. So <span class="math inline">e^{1 - XY} = 1 - XY</span>. Isn’t it amazing? You expand it just like that—no higher power terms are needed.</p>
<p>For Grassmann variables, integration is introduced as differentiation. It’s a definition: <span class="math display">
\int dX \, X = 1, \quad \int dX \, 1 = 0
</span> and <span class="math display">
\int dX \, dY \, e^{-XY} = 1
</span> If you put a constant <span class="math inline">A</span> here, it becomes <span class="math display">
\int dX \, dY \, e^{-A XY} = A
</span> After that, I thought I should spend more time learning about this—it’s fascinating that such a thing exists.</p>
<hr>
<p>You didn’t explain how the determinant pops up, right? How from <span class="math inline">M</span> you get a determinant. There is a formula. You can do this trick for two variables, say <span class="math inline">x_1, x_2</span>, and even then, you get a determinant. It generalizes to higher dimensions.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Fermionic path integral and determinant</strong>: <span class="math display">
\int \mathcal{D}\bar{\psi} \mathcal{D}\psi \, e^{-\bar{\psi} M \psi} = \det M
</span> where <span class="math inline">M</span> is the fermionic operator (Dirac operator in QCD).</p>
</div>
</div>
</div>
<hr>
<p>If we integrate over the gluonic fields, what remains is the integral over all configurations of the quark fields. The operator depends only on the gauge fields, and the determinant represents the effect of virtual quarks. All quarks are integrated, so the only effect is <span class="math inline">\bar{Q}Q</span> popping up from the vacuum. This expression only cares about gluons, and quarks only appear in loops.</p>
<p>Now, important terminology: <strong>quenched and unquenched calculations</strong> refer to this term. When lattice physicists say “quenched calculations,” it means this term is ignored—no quarks in loops. This universe without quark loops is not so different and provides valuable insights into QCD. It’s also much cheaper computationally—the integral converges faster without this term. Remember: <strong>“quenched” means no fermion determinant</strong>.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Quenched approximation</strong>: <span class="math display">
Z_{\text{quenched}} = \int \mathcal{D}A \, e^{-S_{\text{gluon}}[A]}
</span> instead of the full (unquenched) partition function: <span class="math display">
Z_{\text{unquenched}} = \int \mathcal{D}A \, \det M[A] \, e^{-S_{\text{gluon}}[A]}
</span> where <span class="math inline">S_{\text{gluon}}[A]</span> is the gluonic action and <span class="math inline">\det M[A]</span> represents virtual quark loops.</p>
</div>
</div>
</div>
<hr>
<p>The last thing is how we compute this integral. Naively, you could discretize space and integrate over all lattice values. For a lattice of size <span class="math inline">100 \times 200</span> (time × space), how many variables are there? The gluon field <span class="math inline">A_\mu</span> has 4 × 9 components (plus complex parts). That’s 8,640 variables per site. If you replace <span class="math inline">DA</span> with integrals over all these, you’d need <span class="math inline">10^{10}</span> evaluations. Even with 3 points per dimension, it’s <span class="math inline">3^{10^{10}}</span>—impossible to compute in the age of the universe.</p>
<p>Instead, we use <strong>Monte Carlo sampling</strong>. Configurations are sampled randomly with a weight, making the calculation feasible. For lattice QCD, discretize spacetime, use Minkowski transformations, and apply Monte Carlo sampling for the weights. This trick also helps eliminate fermions.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Monte Carlo sampling for lattice QCD</strong>: <span class="math display">
\langle \mathcal{O} \rangle \approx \frac{1}{N} \sum_{i=1}^N \mathcal{O}[A_i]
</span> where <span class="math inline">A_i</span> are gauge field configurations sampled with weight <span class="math inline">e^{-S[A_i]}</span>.</p>
</div>
</div>
</div>
<hr>
<p>If you take these five points home, I’d be happy. With that, I’ll take questions and finish here.</p>
</section>
<section id="fermionic-action-gluon-dependence-and-grassmann-variables-in-qcd" class="level3" data-number="21.6">
<h3 data-number="21.6" class="anchored" data-anchor-id="fermionic-action-gluon-dependence-and-grassmann-variables-in-qcd"><span class="header-section-number">21.6</span> Fermionic Action, Gluon Dependence, and Grassmann Variables in QCD</h3>
<p><strong>Question:</strong> How is it possible that we can split the fermionic and gluon part of the action? If I look at the dimension, I can see that in the long derivative we have terms that give us gluon fields. But then how do we split it?</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>The fermionic part of the action in path integral representation is: <span class="math display"> e^{-S_{\text{fermionic}}} = \int \mathcal{D}\psi \mathcal{D}\bar{\psi} \, e^{\int d^4x \, \bar{\psi}(D + M)\psi} </span></p>
</div>
</div>
</div>
<p>We don’t split it. The fermionic part is this: <span class="math display"> e^{-S_{\text{fermionic}}} = \int \mathcal{D}\psi \mathcal{D}\bar{\psi} \, e^{\int d^4x \, \bar{\psi}(D + M)\psi} </span></p>
<p>Once you integrate over <span class="math inline">\psi</span>, the matrix <span class="math inline">M</span> still depends on the gluon fields.</p>
<hr>
<p><strong>Question:</strong> What is the meaning of <span class="math inline">M</span>? It is <span class="math inline">A</span>.</p>
<p><strong>Question:</strong> But then how did I split my Lagrangian? The full QCD Lagrangian is split as: <span class="math display"> \mathcal{L}_{\text{QCD}} = \mathcal{L}_D + \mathcal{L}_F </span> Here, <span class="math inline">\mathcal{L}_F</span> is still dependent on <span class="math inline">A</span>.</p>
<p><strong>Question:</strong> So <span class="math inline">M</span> is a function of <span class="math inline">A</span>? Yes, <span class="math inline">M</span> is a function of <span class="math inline">A</span>.</p>
<hr>
<p>Ignoring <span class="math inline">D_4</span>, the fermionic part is: <span class="math display"> e^{-S_{\text{fermionic}}} = \int \mathcal{D}\psi \, e^{\int d^4x \, \bar{\psi}(D + M)\psi} </span></p>
<p>When you discretize this integral, it becomes: <span class="math display"> S_{\text{fermionic}} = \bar{\psi} M(A) \psi </span> Here, <span class="math inline">\psi</span> in the lattice space appears as an inner matrix product. The discretized version of the Dirac operator <span class="math inline">D + M</span> is <span class="math inline">M(A)</span>.</p>
<hr>
<p><strong>Question:</strong> Why is it <span class="math inline">+M</span> and not <span class="math inline">-M</span>? The sign change happens when we flip the time derivative. The term <span class="math inline">D</span> flips as: <span class="math display"> \partial_t \rightarrow -\partial_t </span> The gamma matrices are also flipped differently for space and time. For time, it doesn’t flip, but for space, it flips with an <span class="math inline">i</span>. The overall effect is that <span class="math inline">D_4</span> gets a minus sign.</p>
<hr>
<p><strong>Question:</strong> Is this what is called “passing”? These are paths in the gluon field.</p>
<p><strong>Question:</strong> Does a limit exist for quenched and unquenched calculations? Do they converge? I don’t see a limit. They are two independent approaches.</p>
<hr>
<p><strong>Question:</strong> Historically, how was Grassmann algebra developed? How did it come to physics? It existed independently in mathematics before physics applications. I don’t know who introduced it to physics, but it turns out to be very useful.</p>
<p><strong>Question:</strong> Aren’t Grassmann variables limiting? You can’t square them, and series expansions truncate. Yes, but you can still use them to describe fields. It’s a trick, but it works.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>The Dirac operator with mass term is: <span class="math display"> D + M = \gamma^\mu(\partial_\mu - igA_\mu) + M </span> where the sign change in the discretized version occurs due to flipping time derivatives and gamma matrices.</p>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mikhail Mikhasenko">

<title>lecture-06 – Hadron Physics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 6.8em;
  margin: 0 6.8em 6.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-234273d1456647dabc34a594ac50e507.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-c7317bc481e33d2be5001a05e340a262.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#lambda-baryon-decay-weak-interaction-matrix-elements-and-helicity-states" id="toc-lambda-baryon-decay-weak-interaction-matrix-elements-and-helicity-states" class="nav-link active" data-scroll-target="#lambda-baryon-decay-weak-interaction-matrix-elements-and-helicity-states"><span class="header-section-number">6.1</span> Lambda Baryon Decay: Weak Interaction, Matrix Elements, and Helicity States</a></li>
  <li><a href="#distinguishing-canonical-and-helicity-states-in-particle-decays-and-rotations" id="toc-distinguishing-canonical-and-helicity-states-in-particle-decays-and-rotations" class="nav-link" data-scroll-target="#distinguishing-canonical-and-helicity-states-in-particle-decays-and-rotations"><span class="header-section-number">6.2</span> Distinguishing Canonical and Helicity States in Particle Decays and Rotations</a></li>
  <li><a href="#parity-violation-in-asymmetric-angular-distribution" id="toc-parity-violation-in-asymmetric-angular-distribution" class="nav-link" data-scroll-target="#parity-violation-in-asymmetric-angular-distribution"><span class="header-section-number">6.3</span> Parity Violation in Asymmetric Angular Distribution</a></li>
  <li><a href="#polarization-and-angular-distribution-in-λ-decay" id="toc-polarization-and-angular-distribution-in-λ-decay" class="nav-link" data-scroll-target="#polarization-and-angular-distribution-in-λ-decay"><span class="header-section-number">6.4</span> Polarization and Angular Distribution in Λ Decay</a></li>
  <li><a href="#engaging-with-questions-before-the-lecture" id="toc-engaging-with-questions-before-the-lecture" class="nav-link" data-scroll-target="#engaging-with-questions-before-the-lecture"><span class="header-section-number">6.5</span> Engaging with Questions Before the Lecture</a></li>
  <li><a href="#analytic-functions-contour-integrals-and-dispersion-relations" id="toc-analytic-functions-contour-integrals-and-dispersion-relations" class="nav-link" data-scroll-target="#analytic-functions-contour-integrals-and-dispersion-relations"><span class="header-section-number">6.6</span> Analytic Functions, Contour Integrals, and Dispersion Relations</a></li>
  <li><a href="#branch-points-cuts-and-analytic-structure-in-complex-integration" id="toc-branch-points-cuts-and-analytic-structure-in-complex-integration" class="nav-link" data-scroll-target="#branch-points-cuts-and-analytic-structure-in-complex-integration"><span class="header-section-number">6.7</span> Branch Points, Cuts, and Analytic Structure in Complex Integration</a></li>
  <li><a href="#branch-points-poles-and-multivalued-functions-in-complex-analysis" id="toc-branch-points-poles-and-multivalued-functions-in-complex-analysis" class="nav-link" data-scroll-target="#branch-points-poles-and-multivalued-functions-in-complex-analysis"><span class="header-section-number">6.8</span> Branch Points, Poles, and Multivalued Functions in Complex Analysis</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mikhail Mikhasenko </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="lambda-baryon-decay-weak-interaction-matrix-elements-and-helicity-states" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="lambda-baryon-decay-weak-interaction-matrix-elements-and-helicity-states"><span class="header-section-number">6.1</span> Lambda Baryon Decay: Weak Interaction, Matrix Elements, and Helicity States</h3>
<p>Let’s start with the recap. The physics reaction to consider is the lambda baryon decay into a proton and pion: <span class="math display">
\Lambda \to p + \pi^-
</span></p>
<p>We go through our <strong>standard checklist</strong> to understand this reaction:</p>
<ol type="1">
<li>What type of interaction is responsible?</li>
<li>What variables describe the process?</li>
<li>Write the matrix element for the process.</li>
<li>Calculate the polarized decay width.</li>
</ol>
<p>Take two minutes to think about these items, and then we’ll discuss.</p>
<hr>
<p>What interaction is responsible? I like drawing cartoon diagrams (not Feynman diagrams) to visualize this. Here’s the lambda decaying into a proton and pion, with a block representing the interaction.</p>
<p>Is this a <strong>strong interaction</strong>? No, it’s <strong>weak</strong> because flavor is changing: <span class="math display">
u, d, s \to u, d, \bar{u}d
</span> The strangeness changes, and strangeness transitions can only occur via weak interactions. Strong interactions preserve flavor.</p>
<p>Since this is a weak interaction, <strong>parity is not conserved</strong>. This decay violates parity.</p>
<hr>
<p>Now, the first item is to check the particles. The second is: what variables describe the process, and how many are there?</p>
<p>This is a <strong>one-to-two transition</strong>, and we work in the <strong>center-of-mass frame</strong>. The lambda is at rest initially, and the proton and pion are the decay products. The momentum magnitude is fixed by the particle masses. There is no orientation in space, so no angular variables. The only direction is given by the momentum, and we can align the <span class="math inline">z</span>-axis with it.</p>
<hr>
<p>Next, the matrix element. The amplitude for this process is denoted <span class="math inline">H</span>. What does <span class="math inline">H</span> depend on? No variables, because the kinematics are fixed. The only dependencies are the discrete spin projection indices.</p>
<p>The particles involved have spins:</p>
<ul>
<li><strong>Lambda</strong>: <span class="math inline">J^P = \frac{1}{2}^+</span></li>
<li><strong>Proton</strong>: <span class="math inline">J^P = \frac{1}{2}^+</span></li>
<li><strong>Pion</strong>: <span class="math inline">J^P = 0^-</span></li>
</ul>
<p>Since parity is not conserved, the <strong>spin structure matters</strong>. By angular momentum conservation, the proton’s spin projection must match the lambda’s.</p>
<p>The matrix element is written as: <span class="math display">
H_\lambda = \langle p(\vec{p}, \lambda_p), \pi^-(-\vec{p}) | T | \Lambda(0, \lambda_\Lambda) \rangle
</span> Here, <span class="math inline">\lambda_\Lambda = \lambda_p</span> due to spin conservation. The initial state is on the left, and the final state on the right.</p>
<p>The pion is spinless, so its state is <span class="math inline">|0, 0\rangle</span>. The proton has helicity <span class="math inline">\lambda_p</span>, and the lambda has spin projection <span class="math inline">\lambda_\Lambda</span>.</p>
<p>The amplitude <span class="math inline">H_\lambda</span> has two values: <span class="math inline">\lambda = \pm \frac{1}{2}</span>.</p>
<hr>
<p>Next, the unpolarized decay width: <span class="math display">
\Gamma = \frac{1}{2m_\Lambda} \frac{1}{2} \sum_\lambda |H_\lambda|^2 \frac{|\vec{p}|}{8\pi^2 m_\Lambda}
</span> The phase space integral simplifies to 1 because the kinematics are aligned.</p>
<p>This decay is the <strong>main channel</strong> for lambda decay, determining its lifetime of about <span class="math inline">10^{-9}</span> seconds. In experiments, the lambda is identified by its decay to a proton and pion, with charged tracks pointing to a secondary vertex.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Did I forget the <span class="math inline">\frac{1}{2}</span> from <span class="math inline">\frac{1}{2J+1}</span>? No, it’s absorbed correctly because only two terms survive in the sum.</p>
</div>
</div>
</div>
<p>This becomes more interesting when there’s a <strong>preferred direction</strong> in space, such as when the lambda is moving. The direction of motion provides a reference axis, and we can study the decay in the helicity frame.</p>
<hr>
<p>Now, let’s discuss helicity states in more detail.</p>
<p>The <span class="math inline">|JM\rangle</span> states are basis states for a particle with spin <span class="math inline">J</span>, quantized along the <span class="math inline">z</span>-axis with projection <span class="math inline">M</span>. Acting with <span class="math inline">J_z</span> gives: <span class="math display">
J_z |JM\rangle = M |JM\rangle
</span></p>
<p>We use <strong>active transformations</strong>: rotating or boosting the particle, not the coordinate system. For example, boosting a particle along the <span class="math inline">z</span>-axis increases its momentum without changing its spin projection.</p>
<p>Rotating a state about the <span class="math inline">y</span>-axis mixes the spin projections. The coefficients are given by <strong>Wigner D-functions</strong>: <span class="math display">
D^J_{m'm}(\theta) = \langle Jm' | e^{-i\theta J_y} | Jm \rangle
</span></p>
<p>For <strong>spin-<span class="math inline">\frac{1}{2}</span></strong>, the rotation matrix is: <span class="math display">
R_{1/2}(\theta) = e^{-i\theta \sigma_y / 2} = \cos\left(\frac{\theta}{2}\right) - i\sigma_y \sin\left(\frac{\theta}{2}\right)
</span></p>
<hr>
<p>For a moving particle, there are two ways to define spin states:</p>
<ol type="1">
<li><strong>Helicity states</strong>: Spin quantized along the direction of motion.</li>
<li><strong>Canonical states</strong>: Spin quantized along the <span class="math inline">z</span>-axis.</li>
</ol>
<p>These are related. A helicity state is constructed by boosting and rotating a canonical state: <span class="math display">
|p, \lambda\rangle = R(\hat{p}) B_z(p) |0, \lambda\rangle
</span></p>
<p>When you rotate a helicity state, the momentum rotates but the helicity remains the same. Boosting is trickier because it changes the momentum direction relative to the spin.</p>
<p>The <strong>Lorentz boost matrix</strong> for a 4-vector is: <span class="math display">
B_z(\beta) = \begin{pmatrix}
\gamma &amp; 0 &amp; 0 &amp; \gamma\beta \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
\gamma\beta &amp; 0 &amp; 0 &amp; \gamma
\end{pmatrix}, \quad \gamma = \frac{1}{\sqrt{1-\beta^2}}
</span></p>
<p>For canonical states, you first rotate the particle, then boost it. This ensures the spin projection is along the <span class="math inline">z</span>-axis in the lab frame.</p>
</section>
<section id="distinguishing-canonical-and-helicity-states-in-particle-decays-and-rotations" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="distinguishing-canonical-and-helicity-states-in-particle-decays-and-rotations"><span class="header-section-number">6.2</span> Distinguishing Canonical and Helicity States in Particle Decays and Rotations</h3>
<p>Note on the notation: I have to distinguish. When I just tell you <span class="math inline">P, M</span>, you need to ask, is it canonical? Strictly speaking, when you see <span class="math inline">P, J</span>, and then another number, there is no way to figure out whether I’m talking about a canonical state or a helicity state.</p>
<p>However, for the general notation, before I put the numbers here instead of <span class="math inline">M</span> and <span class="math inline">\lambda</span>, <span class="math inline">M</span> usually refers to the z-axis projection, and <span class="math inline">\lambda</span> refers to the helicity. It’s way better if you indicate that explicitly. So if I talk about helicity, I might say “helicity” here, or I can say “canonical” here. Adding these indices to the state to indicate what I’m talking about would be better. If I just say <span class="math inline">J, P</span>, it might be confusing. Still, I will be doing this sometimes because of rushing.</p>
<hr>
<p>Now it’s also clear how to relate the two. But before we start talking about canonical, let me just show you the transformation of canonical states. I want to rotate, and then I immediately rotate. Put a definition of the state: it’s a rotation and then acting on the state <span class="math inline">B^{-1}(P) \ket{0, J, M}</span>. And then I only have to deal with matrices before it becomes something I can apply. So this is equal to… I will try to make on this side the same as I have on the right side to replace these two canonical <span class="math inline">R</span>.</p>
<p>What I have done: I inserted right here <span class="math inline">R'^{-1} R'</span>. Then I put these matrices together, and now this—what is this?—is something that gives me a canonical state if applied to this state at rest. The only thing that remains is I have to apply the rotation operator to the state at rest. And this, you know, is the Wigner D-matrix acting on this state. Therefore, what I’m going to get is the sum of Clebsch-Gordan coefficients.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Key Transformation</strong>: The canonical state <span class="math inline">\ket{P, J, M}_{\text{can}}</span> is defined as: <span class="math display">\ket{P, J, M}_{\text{can}} = R B_z^{-1}(P) \ket{0, J, M}</span> where <span class="math inline">R</span> is the rotation operator and <span class="math inline">B_z^{-1}(P)</span> is the inverse boost along the <span class="math inline">z</span>-axis.</p>
</div>
</div>
</div>
<hr>
<p><strong>Question:</strong> Doesn’t the momentum <span class="math inline">P</span> also change because we change the angle? <strong>Response:</strong> Very good, thanks. So, it gets rotated. But you’re not sure if it’s just <span class="math inline">R P</span>? It should include <span class="math inline">R'</span>. <span class="math inline">R'</span> is the second one—<span class="math inline">R' P</span>. Maybe I would just call it <span class="math inline">P'</span> instead. Somebody else can do the computation. Let me just say <span class="math inline">P'</span> and then explain what <span class="math inline">P'</span> is.</p>
<p>So, <span class="math inline">P'</span> is <span class="math inline">R' P</span>. Or it is also equal to <span class="math inline">R' R</span> acting on <span class="math inline">P_z</span>. Here I boosted, so the momentum became non-zero. Once I boosted after the boost along the z-axis, my momentum is just <span class="math inline">P_z</span>, and then in the following operation, I apply the rotation. So here I apply the rotation, and now <span class="math inline">R' P_z</span>, and that way I get <span class="math inline">P'</span>.</p>
<hr>
<p>I learned how to boost yourself in the exercises, and now let’s discuss their relation to bosons. If you need to relate one to another, this is a gluon state. This is a canonical state. Here we have <span class="math inline">\ket{P, J, M}_{\text{can}}</span>. What I want—I want to write so clearly—they are not equal to each other, but one can express <span class="math inline">\ket{P, J, \lambda}_{\text{hel}}</span> as the linear combination of canonical states. And these coefficients are then… I would like you to have a clear understanding of how we find these coefficients.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Helicity State Relation</strong>: The helicity state <span class="math inline">\ket{P, J, \lambda}_{\text{hel}}</span> can be expressed as: <span class="math display">\ket{P, J, \lambda}_{\text{hel}} = \sum_{M} C_{M \lambda} \ket{P, J, M}_{\text{can}}</span> where <span class="math inline">C_{M \lambda}</span> are Clebsch-Gordan coefficients.</p>
</div>
</div>
</div>
<hr>
<p>I wanted to quickly come back to the lambda decay and tell a little bit more about how we derived the formula. The large peak formula is the many D functions and <span class="math inline">H</span>’s from the last lecture. I’m going to consider now a lambda that moves in the wave frame. It is a helicity state, and then it decays.</p>
<p>In order to get a z-axis, we need the direction of motion of lambda in the lab frame, and that gives us after the boost the z-axis. The way to define the z-axis in this manner is called the helicity frame for lambda. This is when we say “lab frame.” You always have to describe from which frame you are boosting, because it depends. In different frames, the direction of lambda will be different, and there will be differences when you arrive at the rest frame of lambda depending on from which frame you boost it.</p>
<p>The helicity frame is defined as the rest frame of the particle obtained by boosting from the frame where it was moving. The angle of the decay of the particle—when you take one of the particles, particle number one, and use this to define the angle—is called the helicity angle. That’s common jargon in hadron physics. When we talk about the helicity angle, it implies that we boosted to the rest frame and then took one of the particles as the reference and measured the angle from there. But all of the motion is still in the same plane as before. The boost and the two-particle system are now exactly opposite.</p>
<hr>
<p>We start with a lambda flying in the z-direction with a certain velocity. Then it decays. It has a proton and a pion in some plane. And then we invert the boost, and we still have the proton and pion in the same plane. If I took this picture out, you would not have the plane any longer. The plane is formed by three vectors. So I need the original direction of motion of lambda to define the axis with respect to which I can measure the angle, and then I have a plane. This is our recap exercise. We started without knowing that, so we only had one axis. But now we have a plane. Now I have one more variable on which the amplitude depends, in addition to these two discrete variables. This is the scattering angle or the helicity angle.</p>
<p>I have to compute now a final state here going to be frozen binary. Here, on the right side, we have configurations of lambda sitting in its rest state with the proton in lambda. And on the left side, we have this configuration. The way to proceed is to apply rotation to this configuration and arrive at the back. So the answer for this is <span class="math inline">H_{\lambda_p \lambda_\pi} T_{\lambda \lambda}</span>. And the problem of <span class="math inline">T_{\lambda}</span>. That’s the equation we had last time, where I was describing the matrix element for the sequence of the decays.</p>
<p>Let me apply <span class="math inline">T</span> on the final state. I want to simplify this. This is <span class="math inline">T</span> acting on the proton. We want to evaluate the application of the transition operator that takes pion-proton and then transforms this to lambda. This is the meaning of our operator. This operator acting now on the pion-proton state that has the <span class="math inline">P</span> vector <span class="math inline">(0,0)</span>. We notice that this is rotated about the y-axis by the angle <span class="math inline">\theta</span>. We want to align this because, on the left state, we have aligned combinations. So we have a rotation. Now we pull out the rotation, and then we have the same combination now along the z-axis. Proton goes forward, time goes backward, and rotation is explicit.</p>
<p>Since these operators commute—strong interactions conserve spin—therefore, one can compute the transition operator and rotation and then act first with the transition and then by rotation. Essentially, this transition operator transforms pion-proton to lambda. We explicitly do this by inserting the identity state here. Here I have a <span class="math inline">\ket{\lambda}_{\text{hel}}</span> for the left state. This part is a path <span class="math inline">\lambda_p</span>. It’s going to give me just the state of the lambda with the same spin. This matrix element we just evaluated—this is just a Clebsch-Gordan coupling. The identity that we inserted here should have some overall possible combinations. Therefore, that would be a sum over <span class="math inline">\lambda</span>. This will give me delta functions for the <span class="math inline">\lambda_p \lambda_\pi</span>. And that’s why I want only one state—I can do this. Now the last step to do is to apply rotation to it.</p>
<p>It’s good to see it once. But once you get the idea, it’s easy to believe that in the same case of the cascade reaction, what you have for every bit of the transition is the product of this block helicity that is the transition matrix element for the aligned transition. And then the rotation I want to evaluate as well. Now, the differential cross section exists as a function of the angle. This is my equation. We know that these are—so these are our <span class="math inline">\cos \theta, -\sin \theta, \sin \theta, \cos \theta</span> matrices. For the spin-half, we just had an explicit matrix, and we have two coupling constants that are measured in experiment. You can take them to compute the angular distribution.</p>
<p>It’s a little bit disappointing right now if I just tell you the answer. The answer is the same as you had before, because you have a <span class="math inline">\sin^2 \theta + \cos^2 \theta</span>, which is one. And this is in front of the first one. In front of the second one, you have a <span class="math inline">-\sin^2 \theta + \cos^2 \theta</span>.</p>
<p>All right, so what we learned now in this example is that once you have an unpolarized particle, you’re not going to observe any interesting angular distribution. We actually summed over the final state, we summed over the initial state. There is no non-trivial angle distribution that remains for the <span class="math inline">2\pi</span> before we integrate the whole <span class="math inline">\cos \theta</span>. Now we have a differential <span class="math inline">\cos \theta</span>—right before, we just wrote the gamma is equal to… and then the phase space has… it has a <span class="math inline">d\Omega / 4\pi</span>, an integral <span class="math inline">d(\cos \theta) / 2</span>, <span class="math inline">d\phi / 2\pi</span>. This is one decision. And now I just move this <span class="math inline">\cos \theta</span> to the other side.</p>
<hr>
<p>Polarized decay. Now finally, polarized decay. When I get non-trivial distributions if I polarize my particle. So let me say when lambda was flying, it had only spin, only <span class="math inline">\lambda</span>. And now finally we have something. I have a formula. But now let’s try to see what I’m going to see in the experiment.</p>
<p>Lambda travels with a certain momentum, and the projection of the spin to the direction of motion is equal to <span class="math inline">1/2</span>. And then it decays. In the decay of this state, we are going to find that it’s more likely for the proton to travel forward than backward. But this is the angle of the proton. Interestingly, this violates parity. Because you can apply parity to the initial state and final state and find out that by applying parity you flip the momentum, you don’t flip the spin. And then in the final configuration you flip momentum, you don’t flip the spin. So parity implies that there cannot be a symmetry. Parity is violated here. This is also consistent with the fact that we consider inside of the blob here… big decay amplitudes. Parity… we likely put the weak decay in.</p>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Parity Violation in Decay</strong>: The differential decay rate for polarized particles (e.g., <span class="math inline">\Lambda</span>) shows parity violation: <span class="math display">\frac{d\Gamma}{d\cos\theta} \propto 1 + \alpha P \cos\theta</span> where <span class="math inline">\alpha</span> is the asymmetry parameter and <span class="math inline">P</span> is the polarization. This asymmetry arises from weak interactions.</p>
</div>
</div>
</div>
</section>
<section id="parity-violation-in-asymmetric-angular-distribution" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="parity-violation-in-asymmetric-angular-distribution"><span class="header-section-number">6.3</span> Parity Violation in Asymmetric Angular Distribution</h3>
<p>No, it’s not. Well, it is.</p>
<p>You told me that it’s a <strong>linear function</strong>. No, I don’t.</p>
<p>The point is in the <strong>general</strong>. It’s a great question.</p>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Where this parity violation appears is when the two terms are not equal to each other. If they were equal, <span class="math inline">\sin^2\theta + \cos^2\theta</span> would give 1 with no angle dependence.</p>
</div>
</div>
</div>
<p>The parity violation is in the fact that these terms are not equal. This introduces an <strong>asymmetry</strong>, making the distribution angle-dependent, as seen in the formula:</p>
<p><span class="math display">
\frac{d\sigma}{d\Omega} \propto 1 + \alpha \cos\theta
</span></p>
<p>Here, <span class="math inline">\alpha \neq 0</span> signals <strong>parity violation</strong>, breaking the isotropy of <span class="math inline">\sin^2\theta + \cos^2\theta = 1</span>.</p>
</section>
<section id="polarization-and-angular-distribution-in-λ-decay" class="level3" data-number="6.4">
<h3 data-number="6.4" class="anchored" data-anchor-id="polarization-and-angular-distribution-in-λ-decay"><span class="header-section-number">6.4</span> Polarization and Angular Distribution in Λ Decay</h3>
<p>Thanks for the question. That’s <strong>really important</strong> to know, and in fact, they are not.</p>
<p>Moreover, we consider the <strong>polarized decay</strong>: the 100% polarization <span class="math inline">\lambda = \frac{1}{2}</span> is a pure state, a spin projection <span class="math inline">\frac{1}{2}</span>, and it’s fully polarized. One can also consider a <strong>mixed state</strong> where it’s not fully polarized.</p>
<p>Most realistically, the degree of polarization for the <span class="math inline">\Lambda</span> is not 100% but around <strong>60%</strong>. That’s what we have. In the <span class="math inline">B</span> decay case, the <span class="math inline">\Lambda</span> is produced with a polarization of 60%, and in that case, the asymmetry is smaller.</p>
<hr>
<p>The <strong>angular distribution of the decay</strong> is given by:</p>
<p><span class="math display">
\frac{d\Gamma}{d\cos\theta} = \Gamma_0 (1 + \alpha \lambda \cos\theta),
</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\Gamma_0</span> is the <strong>total decay rate</strong>,</li>
<li><span class="math inline">\alpha</span> is the <strong>analyzing power</strong> (polarizing power),</li>
<li><span class="math inline">\lambda</span> is the <strong>degree of polarization</strong> (<span class="math inline">0 \leq \lambda \leq 1</span>),</li>
<li><span class="math inline">\theta</span> is the <strong>decay angle</strong>.</li>
</ul>
<hr>
<p>We can rewrite these equations by contracting the matrix element with the polarization matrix and find that the <strong>difference between two edges</strong> defines how well this particular decay reflects polarization. The quantity <span class="math inline">\alpha</span> is often called the <strong>polarizing power</strong>. It tells you how well this decay is suited to measure the initial polarization.</p>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>If the couplings are equal to each other, you don’t have sensitivity to the initial polarization. It can also happen even for big decays that the couplings are equal. Parity can be violated, but for most cases, there is a non-zero analyzing power.</p>
</div>
</div>
</div>
<p>This <span class="math inline">\alpha</span> is <strong>non-zero</strong>, and that’s why by looking at the angular distribution, you see <strong>parity violation</strong>. But you can also measure the initial polarization. That’s called the <strong>polarimetry technique</strong>, and it’s actively used.</p>
<hr>
<p>Look at the angular distributions. All particles have <strong>known spin</strong>, and the couplings are known. But these values have to be measured in advance, and in that case, you can measure polarization.</p>
<p>This <strong>initial polarization</strong> is a <strong>super powerful observable</strong>. Particles like <span class="math inline">\Lambda</span> with spin carry polarization out of the interaction point, which is part of the information. How <span class="math inline">\Lambda</span> is produced—with what momentum and with what polarization—tells us about the <strong>internals of the interaction</strong>.</p>
<p>Imagine <span class="math inline">\Lambda</span> is produced in the <strong>quark-gluon plasma</strong>. Its polarization can now be related to the properties of the plasma. This is a kind of <strong>free carrier of information</strong> out of the mess of the quark-gluon interaction.</p>
<p>Polarization plays an <strong>important role</strong>, if not more than other observables. This particle not only carries polarization but also, by decaying, gives us a way to measure it.</p>
<hr>
</section>
<section id="engaging-with-questions-before-the-lecture" class="level3" data-number="6.5">
<h3 data-number="6.5" class="anchored" data-anchor-id="engaging-with-questions-before-the-lecture"><span class="header-section-number">6.5</span> Engaging with Questions Before the Lecture</h3>
<p><strong>Questions, questions, questions.</strong> We have time, but it is up.</p>
<p>Instead of starting a new lecture, I would like to give you <em>a question I have in mind</em> for the lecture. For example:</p>
<ul>
<li>If I were to explain the material to you, you would already know it</li>
<li>But I haven’t</li>
</ul>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>The speaker is using a Socratic approach - testing understanding before delivering content. Common in physics lectures to gauge baseline knowledge.</p>
</div>
</div>
</div>
<p>So I’ll just give you the question and see if you know it <em>without my lecture</em>. Meanwhile, tell me if you have questions.</p>
</section>
<section id="analytic-functions-contour-integrals-and-dispersion-relations" class="level3" data-number="6.6">
<h3 data-number="6.6" class="anchored" data-anchor-id="analytic-functions-contour-integrals-and-dispersion-relations"><span class="header-section-number">6.6</span> Analytic Functions, Contour Integrals, and Dispersion Relations</h3>
<p>Can you find half or maybe a quarter page? Maybe we can take Ilya—can you help obtain quarter-page pieces of paper?</p>
<hr>
<p><strong>Next lecture</strong>, we will move on to discussing <strong>analytic functions</strong> and properties of amplitudes in the complex plane. This requires you to have a little bit of <strong>complex analysis</strong>. We’ll discuss this further—the next sheet also has a bit of discussion on the complex plane.</p>
<p>So, we need a little bit of <strong>complex algebra</strong>, from 1 to 7. From 1 to 7. Let me just say where this comes from.</p>
<hr>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Key Theorem</strong>: The <strong>Cauchy Integral Theorem</strong> states that for any analytic function <span class="math inline">F(z)</span> inside and on a closed contour <span class="math inline">C</span>: <span class="math display">
\oint_C F(z) \, dz = 0.
</span></p>
</div>
</div>
</div>
<p>What is written here is obtained by doing the <strong>contour integral</strong>. I started with a small circle—my function is analytic—and I’m going to stretch the circle in all directions. This is my complex plane (<span class="math inline">x</span>-plane).</p>
<p>The <strong>Cauchy integral</strong> of <span class="math inline">F(x)</span>, if no singularities occur inside my integration contour, is zero for any analytic function: <span class="math display">
\oint_C F(z) \, dz = 0.
</span></p>
<hr>
<p>Then, there is a theorem that tells me I can insert a <strong>singularity</strong> explicitly inside the circle. If I integrate <span class="math inline">\frac{F(x')}{x' - x} \, dx'</span> and integrate this around—the integral was zero, but now let me put a pole explicitly inside like this.</p>
<p>When I integrate, my integral is no longer zero—it’s equal to the function evaluated at the pole, and that’s my <span class="math inline">F</span>. This is given by <strong>Cauchy’s Integral Formula</strong>: <span class="math display">
F(a) = \frac{1}{2\pi i} \oint_C \frac{F(z)}{z - a} \, dz.
</span></p>
<hr>
<p>Now, I have this beast here. It’s something similar, but I started from a small contour and stretched it to infinity. Here is infinity—this part of the contour drops out, and the only thing that remains is the integral from 1 to 7.</p>
<p>I’m integrating the <strong>imaginary part</strong> of <span class="math inline">F(x)</span> from 1 to 7 and asking: Can this equation be satisfied? This relates to the <strong>dispersion relation</strong>: <span class="math display">
\text{Re}\, F(x) = \frac{1}{\pi} \mathcal{P} \int_{1}^{7} \frac{\text{Im}\, F(x')}{x' - x} \, dx'.
</span></p>
<hr>
<p><strong>Second question</strong>: What is the <strong>analytic structure</strong>? What do you mean by “analytic”?</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Analytic Functions</strong>: A function is <strong>analytic</strong> in a region if it is <strong>complex differentiable</strong> at every point in that region. This implies the function is infinitely differentiable and can be represented by a <strong>power series</strong> locally.</p>
</div>
</div>
</div>
</section>
<section id="branch-points-cuts-and-analytic-structure-in-complex-integration" class="level3" data-number="6.7">
<h3 data-number="6.7" class="anchored" data-anchor-id="branch-points-cuts-and-analytic-structure-in-complex-integration"><span class="header-section-number">6.7</span> Branch Points, Cuts, and Analytic Structure in Complex Integration</h3>
<p>Cut both branch points. This is <strong>super unusual</strong> for math courses, but that’s what we use all the time in physics—this type of integral where the leftover of the contour is from <span class="math inline">1</span> to <span class="math inline">7</span>, and what you integrate is your function <span class="math inline">F</span>.</p>
<p>Since it comes from both sides, from this side and that side, and they have opposite signs, what remains is the <strong>imaginary part</strong>. The real part is the same. It cancels out when you calculate. So the thing that remains is the integral from the same.</p>
<p>If you have anything to say about that, write it down. Maybe it’s too complicated.</p>
<hr>
<p>Let’s make a round. Say a few words about this. Start with:</p>
<ul>
<li>Can you be satisfied?</li>
<li>Can we be satisfied?</li>
</ul>
<p>Three is a solution. You can just take the constant <span class="math inline">3</span> because it has no imaginary part. The real question is, if you remove the three, at least there are <strong>non-trivial solutions</strong>. Sometimes non-constant words like <em>non-vanishing</em>.</p>
<p>If you say <span class="math inline">F(X) = 3</span>, it has no imaginary part. Then the imaginary part is not present anywhere. The question is, if you remove the three—well, that’s the question.</p>
<p>If you just ask this, I think you’re completely right. But I was actually thinking of <strong>non-trivial solutions</strong>. Do we say it exists or not?</p>
<hr>
<p>You can probably put power series in. It might work—<strong>totally could work</strong>.</p>
<p>It can be satisfied. The answer is: Give me any function, whatever you want. I put it here. Any function <span class="math inline">X</span>—that integral actually converges for any value.</p>
<p>Take <span class="math inline">\sqrt{X}</span>. Put it here, and it’s satisfied. Just anything put inside the imaginary part, it’s satisfied. The reason we’re satisfied is this: it’s a way to construct the function.</p>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>The function <span class="math inline">F(X)</span> can be constructed using the integral representation: <span class="math display">
F(x) = \frac{1}{\pi} \int_1^7 \frac{\sqrt{t}}{t - x} dt
</span> where the integral is taken along the real axis, avoiding the branch cut.</p>
</div>
</div>
</div>
<hr>
<p>Let me show you: this <span class="math inline">\sqrt{X}</span>, I put it here instead of this expression, <span class="math inline">\sqrt{X}</span>. Then this way I compute my function <span class="math inline">F(X)</span>. This is a <strong>super special function</strong>. Its imaginary part is equal to <span class="math inline">\sqrt{X}</span> in the region from <span class="math inline">-1</span> to <span class="math inline">7</span>.</p>
<p>In <span class="math inline">-1</span> to <span class="math inline">7</span>, if I evaluate, the imaginary part is equal to that. In the rest of the complex plane, the function is non-zero. But there are no singularities.</p>
<p>This insertion that I made is actually done by introducing some <strong>non-trivial analytic structures</strong>. Now we have three candidates. Let’s give them votes.</p>
<hr>
<p>What kind of non-analytic structures have I introduced? It’s like a continuous stretch of poles—a stretch of poles. What is meant by a cut? They just end somewhere.</p>
<p>The cut is the non-analytic structure where the function on one side is different from the function on the other side. It’s like <span class="math inline">\sqrt{-1 + i}</span> and <span class="math inline">\sqrt{-1 - i}</span>.</p>
<p>We see that this one is equal to <span class="math inline">+i</span> and this one is equal to <span class="math inline">-i</span>. On different sides, I have different values. This is a cut. It’s not really anything else than a spectrum of poles.</p>
<p>Poles have divergence, and this thing does not have divergence. So what will you say? You go for poles.</p>
<hr>
<p>Are you attracted by the concept of <strong>branch points</strong> or <strong>cuts</strong>? I was thinking about cuts, but now I’m convinced both solutions are not poles.</p>
<p>In the integral, there are no poles. The integrand has poles, but they are at zero.</p>
<p>You have to analytically continue something. It’s like you probably have to take it above the complex line or the real line, and below, probably differently.</p>
<p>The branch point is where it starts and where it ends. You forget about the branch work for the elements.</p>
<hr>
<p>The analytic structure of my function in the <span class="math inline">X</span> plane has:</p>
<ul>
<li>A branch point at <span class="math inline">1</span>,</li>
<li>A branch point at <span class="math inline">7</span>,</li>
<li>And they’re connected by a cut.</li>
</ul>
<p>There are no poles. The function doesn’t have any poles.</p>
<p>The way we construct the function here—in this way, you introduce on the cut, you don’t do your space.</p>
<hr>
<p>It’s really funny to think where this guy didn’t come from, go where. You can look at this plane and take a walk here. You don’t experience any poles, any singularities.</p>
<p>We can dive under. You end up in a different world that has a gate. Through the gate, you go to the other world. There you find poles—this is zero, it has poles. And it has <span class="math inline">\sqrt{X}</span>, so it has another cut.</p>
<p>The function has an <strong>interesting and complicated structure</strong> in the complex plane. On the regular complex plane where we call the function, it doesn’t have any singularities except one gate.</p>
<p>Through the gate, you can go to the other so-called sheet, and there you have a lot of stuff going on.</p>
<hr>
<p>You just get used to it. It’s really fun to think of this. We will discuss a little bit more of the complex chart structure and how scattering—what is actually the complex structure of the scattering amplitudes.</p>
</section>
<section id="branch-points-poles-and-multivalued-functions-in-complex-analysis" class="level3" data-number="6.8">
<h3 data-number="6.8" class="anchored" data-anchor-id="branch-points-poles-and-multivalued-functions-in-complex-analysis"><span class="header-section-number">6.8</span> Branch Points, Poles, and Multivalued Functions in Complex Analysis</h3>
<p><strong>Opening Remarks:</strong> <em>Sorry for being late, and thanks for coming.</em> <em>We have a two-week break next week.</em> <em>We don’t have class, so have a nice holiday.</em></p>
<hr>
<p><strong>Simplifying the Problem:</strong> <em>Let’s make it simpler because it can be.</em> <em>Let’s make a constant in order to simplify—oh, I don’t even need this.</em></p>
<hr>
<p><strong>Integration and Logarithmic Behavior:</strong> The integral will always converge from 1 to 7. This is what we have. This is a logarithm. The logarithm itself can have a pole.</p>
<p>Let’s evaluate the function at 8: <span class="math display">
\log(1 - 8) - \log(17 - 8).
</span> I’m going to say <span class="math inline">8 \pm \epsilon</span>, and then: <span class="math display">
\log(1) = 0, \quad \log(-1) = i\pi.
</span> <span class="math display">
\log(-x) = \log(x) + i\pi.
</span></p>
<hr>
<p><strong>Results and Continuity:</strong> We arrive at the result that may equal each other. The difference here is <span class="math inline">-i\pi</span> and <span class="math inline">+i\pi</span>. In the equation, this is continuous, and here is the jump. The real part of <span class="math inline">x</span> cannot be between 1 and 7 because we want to have a structure around it.</p>
<p>We cannot have <span class="math inline">x</span> from 1 to 7 because we have the structures looping around it. The structure is looking around. You introduced the branch points at the edges and then a cut connecting these points.</p>
<hr>
<p><strong>Singularities and Branch Points:</strong> It’s explicitly clear on the determinant itself by doing a simple integral. This expression has an <span class="math inline">n</span>-structure: a cut, branch point at 1, branch point at 7, and then a cut. Is it anything else but a pole? No.</p>
<p>A branch point can have a divergence—like the function could be infinity there—but it doesn’t have to. This function’s branch point is zero. The function is zero here; the function is infinity here.</p>
<p>The pole is this: <span class="math display">
\frac{1}{x^3} \text{ is a pole of third order.}
</span> <span class="math display">
\frac{1}{(x - c)\log(x - c)} \text{ is not a pole.}
</span></p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Key distinction:</strong></p>
<ul>
<li>A <strong>pole</strong> is an isolated singularity that can be resolved by an infinitesimal shift in the complex plane.</li>
<li>A <strong>branch point</strong> (e.g., for <span class="math inline">\sqrt{x}</span> or <span class="math inline">\log(x)</span>) is non-isolated and requires branch cuts to define the function uniquely.</li>
</ul>
</div>
</div>
</div>
<hr>
<p><strong>Teaching Style and Context:</strong> <em>For us, your lectures are a bit unstructured, and you’re a bit all over the place.</em> <em>But it also makes it more fun because of your sketches of boosts, beasts, and rotations—just sketches.</em> <em>You don’t really prove anything like in other courses.</em> <em>It’s not a strict or rigorous proof of everything—it’s just not fun for a while.</em></p>
<p><em>I’m fine teaching advanced people, but you have to be more structured for younger students.</em></p>
<hr>
<p><strong>Metaphor of “Gates” and Multivalued Functions:</strong> We go through the gate, but outside the gate, you said the function is fine, it’s continuous. Here you said it’s another gate. This is the first world, second world enter. Here we can walk around the gate; it’s fine. But then it goes through the gate and ends up in another world.</p>
<p>You can go through the gate and appear in that world. It has many more gates. You can go around this and enter on the other side—that’s where you come out here. If you do this, you are not at the end.</p>
<p>It’s a third world. Then it’s an infinite number of worlds because it’s a loop at infinity. This gives an infinite number of worlds, but this one is simpler.</p>
<hr>
<p><strong>Practical Application and Fun Idea:</strong> Imagine taking VR glasses and walking through this. That would be quite fun. You can suggest this to Matrix Netflix. Make it an escape room—you only get out if you find the first gate.</p>
<hr>
<p><strong>Connection to Physics:</strong> Where does this function appear? All scattering amplitudes as functions of <strong>Mandelstam variables</strong> (<span class="math inline">s, t, u</span>) have energies—the area state.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mikhail Mikhasenko">

<title>lecture-08 – Hadron Physics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 19.8em;
  margin: 0 19.8em 19.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-a6e161b2431e1f94a14e0f5d32135a3c.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7d3a565c23c4d3b0e7c030e96a8964f3.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#scattering-matrix-unitarity-and-the-k-matrix-formalism" id="toc-scattering-matrix-unitarity-and-the-k-matrix-formalism" class="nav-link active" data-scroll-target="#scattering-matrix-unitarity-and-the-k-matrix-formalism"><span class="header-section-number">19.1</span> Scattering Matrix, Unitarity, and the K-Matrix Formalism</a></li>
  <li><a href="#two-resonance-dynamics-and-unitary-constraints-in-scattering-theory" id="toc-two-resonance-dynamics-and-unitary-constraints-in-scattering-theory" class="nav-link" data-scroll-target="#two-resonance-dynamics-and-unitary-constraints-in-scattering-theory"><span class="header-section-number">19.2</span> Two-Resonance Dynamics and Unitary Constraints in Scattering Theory</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mikhail Mikhasenko </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="scattering-matrix-unitarity-and-the-k-matrix-formalism" class="level3" data-number="19.1">
<h3 data-number="19.1" class="anchored" data-anchor-id="scattering-matrix-unitarity-and-the-k-matrix-formalism"><span class="header-section-number">19.1</span> Scattering Matrix, Unitarity, and the K-Matrix Formalism</h3>
<p>We start with <strong>recap problems</strong>. Here all three are positive. So:</p>
<ul>
<li><span class="math inline">G</span> is positive,</li>
<li><span class="math inline">S</span> is positive,</li>
<li>and also <span class="math inline">U</span> is positive.</li>
</ul>
<p>This would happen if we have a constellation where one of the particles decays into the other three, and we then have a <strong>Dalitz plot</strong> here.</p>
<p>For the <span class="math inline">S</span> channel, we can see that:</p>
<ul>
<li><span class="math inline">U</span> is negative</li>
<li><span class="math inline">T</span> is negative</li>
</ul>
<p>Depending on what type of reaction you have—for example, if it’s an <strong>elastic scattering</strong> or <strong>non-elastic scattering</strong> reaction—we can also have mass constraints here.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Elastic vs.&nbsp;Non-Elastic Scattering</strong>:</p>
<ul>
<li>If it’s elastic, then this would be just the masses here four times, and similarly here as well.</li>
<li>For non-elastic, the constraints differ.</li>
</ul>
</div>
</div>
</div>
<p>In general, there’s a function called the <strong>Kibble function</strong> that gives us the constraints and how exactly these areas are constrained. We just put some variation here.</p>
<p>What I have sketched is the more general case where we don’t have elastic scattering. For elastic scattering, we would have a different kind of border where it would go a little bit over here.</p>
<p>You can look this Kibble function up, for example, in the book by <strong>Spearman and Martin</strong>. There, different cases are discussed on how these borders change when you have inelastic or elastic scattering.</p>
<hr>
<p>Now let’s move on to the <strong>scattering matrix</strong>. You have two terms:</p>
<ol type="1">
<li>The <strong>identity matrix</strong> (<span class="math inline">\mathbb{I}</span>)</li>
<li>The <strong>transition matrix</strong> (<span class="math inline">T</span>)</li>
</ol>
<p>This means when we have scattering where basically nothing happens, we use the identity matrix. Here is where the interaction is then included.</p>
<p>Because of the way it’s written—it’s not clear—let me write it again:</p>
<p><span class="math display">
S = \mathbb{I} + 2\pi i \, T
</span></p>
<p>This means <strong>no interaction</strong>.</p>
<p>An important condition we have is that the probability of finding a system in a certain state must sum to one.</p>
<ul>
<li>You can have a sum of different possibilities for the probability, and the total should always be one.</li>
<li>We can’t have more than one, so the total conservation of probability is given for <span class="math inline">n</span> different states for a certain initial state.</li>
</ul>
<p>This is just the identity. If you take any two different orthogonal states, this conservation of probability means that <span class="math inline">S</span> has to be a <strong>unitary matrix</strong>. This condition is called <strong>unitarity</strong>:</p>
<p><span class="math display">
S^\dagger S = \mathbb{I}
</span></p>
<p>If you now use what we have written down for the scattering matrix—the identity matrix plus <span class="math inline">2\pi i</span> times the transition matrix <span class="math inline">T</span>—let’s put this into the unitarity condition and see what comes out.</p>
<p>This has to satisfy the unitarity condition. What we can do is cross this out and move these two terms, for example, to the other side. You can also divide by <span class="math inline">2\pi i</span>.</p>
<hr>
<p>When we want to calculate, for example, a <strong>cross section</strong> or <strong>transition probabilities</strong>, we do it like this:</p>
<ol type="1">
<li>We have an initial and final state</li>
<li>Then the transition between them</li>
</ol>
<p>If you put this condition here, you sum over different states. In principle, you can also write this as an integral over the <strong>phase space</strong>.</p>
<p>If we look at an initial and final state, we can:</p>
<ul>
<li>Sum over all the different spin projections</li>
<li>Write it either as a sum or as an integral over the phase space</li>
</ul>
<p>These are basically the <strong>phase space vectors</strong> that come in.</p>
<p>When you insert identity, it’s written as the integral over possible states. Here’s the insertion of that identity, and it comes within the phase space.</p>
<p>So identity then—if you have two particles with two momenta, the identity can be expressed as the integral over the phase space of these states:</p>
<p><span class="math display">
\mathbb{I} = \int d^3p_1 \, d^3p_2 \, (2\pi)^4 \delta^4(p_0 - p_1 - p_2)
</span></p>
<p>When you insert identity, you integrate over all momentum. You don’t constrain particles to be on-shell in energy, only in mass. So it’s not a <span class="math inline">\delta^5</span> but rather <span class="math inline">d^3p_1 \, d^3p_2</span>.</p>
<p>The phase space comes once you add the delta function constraint:</p>
<p><span class="math display">
(2\pi)\delta(E_2 - E_1 - E_2)
</span></p>
<p>and then for each particle. The difference between phase space and this integral is the <span class="math inline">\delta^4(p_0 - p_1 - p_2)</span>, the energy-momentum conservation that comes from the matrix element.</p>
<p>From any of that, it comes with a <span class="math inline">\delta^4</span> for energy-momentum conservation, like this:</p>
<p><span class="math display">
\langle f | T | i \rangle \propto \delta^4(p_f - p_i) \cdot \mathcal{M}
</span></p>
<hr>
<p>Now let’s think about the <strong>scattering amplitude</strong>. Here we have two particles, 1 and 2. We can look, for example, in the <strong>center-of-mass system</strong> where we define the <span class="math inline">z</span>-axis in the direction of motion of <span class="math inline">p_1</span> and <span class="math inline">p_2</span>.</p>
<p>They are just 180 degrees to each other. Here we have the <strong>scattering angle</strong> <span class="math inline">\theta</span>. In the center-of-mass frame, the momenta are equal and opposite to each other.</p>
<p>This we can then express as the scattering amplitude part and then a part where we have momentum conservation. This scattering amplitude depends on variables like <span class="math inline">s</span> and <span class="math inline">t</span>.</p>
<p>In practice, we usually fix, for example, <span class="math inline">t</span> and then look at the <span class="math inline">s</span>-dependence. We can write the scattering amplitude and decompose it into different <strong>partial waves</strong>:</p>
<p><span class="math display">
A(s,t) = \sum_j (2j + 1) \, A_j(s) \, P_j(\cos \theta)
</span></p>
<p>A <strong>partial wave expansion</strong> means we decompose the scattering amplitude into an infinite series of these partial waves, where we sum over the spin <span class="math inline">j</span>.</p>
<p>Here we have the <strong>Legendre polynomials</strong> describing the angle dependence. Then you have a term that depends on <span class="math inline">s</span> minus some variable—this is where the mass dependence goes in, describing the resonance, its mass, width, and so on.</p>
<p>This is practical because what we measure in experiments are <strong>angular distributions</strong>. We know that if you’re looking for certain states or resonances, they have a definite spin <span class="math inline">j</span>.</p>
<p>When we do this partial wave decomposition, we can divide up the different contributions we see in the data, making it easier to recognize new states.</p>
<p>These Legendre polynomials can be related to the <strong>Wigner <span class="math inline">D</span>-functions</strong>. I also want to write this down in the notation we had previously, with helicity states.</p>
<p>For example, with two particles, we have the angle <span class="math inline">\theta</span> and an azimuthal angle <span class="math inline">\phi</span>. This is another way to write this, where we now have the partial wave amplitudes as a reminder:</p>
<p><span class="math display">
A(s, \theta, \phi) = \sum_j A_j(s) \, D^j_{\lambda \lambda'}(\theta, \phi)
</span></p>
<p>The big Wigner <span class="math inline">D</span>-functions depend on <span class="math inline">\theta</span>.</p>
<hr>
<p>Before we discuss how to parameterize the mass dependence here, let’s first look at what the <strong>unitarity constraints</strong> mean for the scattering amplitude and for <span class="math inline">A_j</span>.</p>
<p>You can see up there the unitarity constraint. If you apply this to the scattering amplitude—and for the partial waves, you can also write this down—<span class="math inline">\rho</span> is the phase space factor.</p>
<p>What does it mean? These are complex numbers, so you can write this as the real part <span class="math inline">A</span> plus <span class="math inline">i</span> times the imaginary part of <span class="math inline">A</span>, and this with a minus in between.</p>
<p>What remains here is <span class="math inline">2i</span> times the imaginary part if we subtract this.</p>
<p>This is what the unitarity constraints mean for the scattering amplitude and the partial waves. What I want to discuss next is how we can describe the energy dependence for this.</p>
<p>We have already discussed a couple of times that what we can see, for example in the cross section, is a peak which we then call a <strong>resonance</strong>.</p>
<p>The question is: how can we describe this? If we have, for example, two particles where we added the four-momenta and then looked at their mass, and we see a peak-like structure here.</p>
<p>One of the easiest ways to describe this shape is with a <strong>relativistic Breit-Wigner amplitude</strong>:</p>
<p><span class="math display">
A(s) = \frac{g^2 \, \rho(s)}{M^2 - s - i M \Gamma(s)}
</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">M</span> = mass of the resonance</li>
<li><span class="math inline">\Gamma</span> = coupling of the resonance to the initial and final state</li>
<li><span class="math inline">\rho(s)</span> = phase space</li>
</ul>
<p>We are not just interested in the mass, but also what the width here is. This is, in this case, related to this part. So this is roughly the width divided by two.</p>
<p>This type of concept works well when we have an <strong>isolated resonance</strong>. One really good example for this is the <span class="math inline">\Delta(1232)</span> resonance, where the mass is at 1232 MeV.</p>
<p>The next <span class="math inline">\Delta</span> resonance that we have in the spectrum comes at around 1600 MeV. We can safely assume that it is isolated enough so we can use this kind of amplitude to describe it.</p>
<p>We also talked briefly about what kind of width to expect. It’s very different, depending on what kind of states you’re looking at.</p>
<ul>
<li>If you are in the <strong>low-mass quark region</strong>, like we have the <span class="math inline">\Delta</span> or the nucleon resonances, there we have widths of over 100 MeV.</li>
<li>If we are in the <strong>heavy quark sector</strong>, then most of them are so narrow that the width is just given by the detector resolution.</li>
</ul>
<p>Since we have been talking about unitarity, one important thing here is that for a single isolated resonance, the Breit-Wigner description fulfills unitarity.</p>
<p>Unfortunately, in experiments and in reality, we often have the situation where we have <strong>overlapping resonances</strong>, and simply summing up two Breit-Wigners, for example, would not give us unitarity. The unitarity condition would then not be fulfilled.</p>
<p>What we do then instead is to basically start from unitarity and construct a matrix called the <strong><span class="math inline">K</span>-matrix</strong>, which fulfills unitarity:</p>
<p><span class="math display">
T = K (\mathbb{I} - i \rho K)^{-1}
</span></p>
<p>This is what we want to do next.</p>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Correction</strong>: The denominator of the amplitude has <span class="math inline">g^2</span> times <span class="math inline">\rho</span>, which is mass times width, not just <span class="math inline">\Gamma</span>. So it’s not <span class="math inline">\Gamma</span> over two. It’s <span class="math inline">M \Gamma</span>.</p>
</div>
</div>
</div>
<p>Let’s start with our unitarity condition. We can now bring one of the <span class="math inline">T</span>’s to the other side and also split this up. So we have here <span class="math inline">2i</span> times the identity matrix.</p>
<p>What we get is we bring this here. This part here is what we call the <span class="math inline">K</span>-matrix <span class="math inline">N^{-1}</span>. Since there’s an equal sign between this means that <span class="math inline">K</span> has to be <strong>Hermitian</strong>.</p>
<p>If we want symmetry between going from an initial state to a final state and the other way around, having the final state as the initial state going to it, then we know that <span class="math inline">K</span> has real values and is symmetric.</p>
<p>Instead of writing here the transition matrix, we can also write it as the phase space matrix times the invariant matrix and then square root of again phase space matrix.</p>
<p>We can also write <span class="math inline">K</span> in terms of <span class="math inline">T</span>. In principle, with this kind of definition, either with <span class="math inline">T</span> or with this invariant matrix <span class="math inline">M</span>, we can expand this into an infinite series with this <span class="math inline">K</span>-matrix.</p>
<p>This <span class="math inline">K</span>-matrix describes here this interaction. Here we have also terms where we have some intermediate state here, or more than one, and so on. This can be expanded into this infinite series.</p>
<p>Now I want to discuss two cases that we have, for example, one single resonance in one channel and how this <span class="math inline">K</span>-matrix can be then modeled.</p>
<p>If you have one resonance and it can only decay into one single channel, this is how we can parameterize it:</p>
<p><span class="math display">
K = \frac{g^2}{M^2 - s}
</span></p>
<p>We have again coupling constants, the mass of the resonance, and <span class="math inline">s</span>.</p>
<p>If we now plug this into the invariant matrix, the invariant amplitudes—so what we get out if we do this—is we get again the Breit-Wigner amplitude out.</p>
<p>For the single resonance case, this Breit-Wigner parametrization gives us also unitarity. This is what we also get out using this <span class="math inline">K</span>-matrix approach.</p>
<p>In general, the width can also depend on <span class="math inline">s</span>. So that’s not a constant width.</p>
</section>
<section id="two-resonance-dynamics-and-unitary-constraints-in-scattering-theory" class="level3" data-number="19.2">
<h3 data-number="19.2" class="anchored" data-anchor-id="two-resonance-dynamics-and-unitary-constraints-in-scattering-theory"><span class="header-section-number">19.2</span> Two-Resonance Dynamics and Unitary Constraints in Scattering Theory</h3>
<p>Now let’s think about <strong>single-channel two resonances</strong>. Imagine we have this plot with two peaks. What we can see here is that this does not correspond to the sum of two <span class="math inline">\pi</span> thresholds. We also don’t want this because it doesn’t fulfill unitarity.</p>
<hr>
<p>If the masses of the two resonances are far apart, this part would vanish, and we would have just the sum of two Breit-Wigner peaks:</p>
<p><span class="math display">
f(E) = \sum_{j=1}^2 \frac{g_j^2}{E - E_j + i\Gamma_j/2}.
</span></p>
<p>In this case, they are so far apart that we can consider them <strong>isolated</strong>. If the masses were the same, we would get just one single peak.</p>
<hr>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>The Breit-Wigner formula describes isolated resonances: <span class="math display">f(E) = \frac{\Gamma/2}{(E - E_0) + i\Gamma/2}</span> For two resonances, we sum their individual contributions when they’re far apart.</p>
</div>
</div>
</div>
<hr>
<p>We have only a couple of minutes left. One important thing to remember is that we are looking at:</p>
<ul>
<li>The <strong>imaginary part</strong> of the partial wave</li>
<li>The <strong>phase shifts</strong></li>
</ul>
<p>We expect to see:</p>
<ul>
<li>A peak in the imaginary part</li>
<li>In the real part, we see a phase motion going through zero</li>
</ul>
<hr>
<p>The best way to intuitively understand this is to think back to mechanics. In a thought experiment with an external frequency scan, you would observe:</p>
<ol type="1">
<li>A resonance at a certain eigenfrequency</li>
<li>A phase motion going through 90 degrees</li>
</ol>
<p>This is similar here: for a resonance state, we also see this phase motion.</p>
<hr>
<p>This ideal behavior only occurs for an <strong>isolated resonance</strong>. With overlapping resonances, it becomes much more complicated to determine:</p>
<ul>
<li>How many resonances there are</li>
<li>How to parameterize them</li>
</ul>
<hr>
<p>Probably about 5. We already have this from the nuclear top machine. The Argand diagram plots:</p>
<ul>
<li>The imaginary part against the real part of <span class="math inline">F</span></li>
<li>Forms a circle</li>
</ul>
<p>We can examine specific values on this circle.</p>
<hr>
<p>For elastic scattering, the energy dependence describes the unitary circle:</p>
<p><span class="math display">
(\text{Re}\,f)^2 + \left(\text{Im}\,f - \frac{1}{2}\right)^2 = \left(\frac{1}{2}\right)^2.
</span></p>
<p>Different points on the circle satisfy this equation. For example, at 45 degrees, we would get <span class="math inline">1/2 + i/2</span>.</p>
<hr>
<p>The circle is centered around <span class="math inline">(x_0, y_0)</span> with radius <span class="math inline">R</span>. For non-elastic scattering:</p>
<ul>
<li>There is a deviation from this circle, moving inward</li>
<li>If unitarity is not fulfilled (as in the case of two-body weakness), the trajectory would go <strong>outside</strong> the unitary circle</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>